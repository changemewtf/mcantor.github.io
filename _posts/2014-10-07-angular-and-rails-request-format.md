---
layout: post
title: "Request Format Detection with Angular and Rails"
date: 2014-10-07 06:00:00
---

# Or, "I Hate Web Development"

So I was brushing up on Angular today.

I was just working on a simple little proof-of-concept app that allows
people to make media recommendations to their friends.

I didn't have much of the JS written yet:

{% highlight javascript %}
// app/assets/javascripts/recommendations.js

angular.module('recs', ['ngResource'])

    .factory('Recommendation', ['$resource', function($resource) {
        return $resource('/recommendations/:id');
    }])

    .factory('Media', ['$resource', function($resource) {
        return $resource('/media/:id');
    }])

    .controller('RecommendationsController', ['$scope', 'Recommendation', 'Media', function($scope, Recommendation, Media) {
        // Load JSON bootstrapped into the view to skip extraneous AJAX request
        this.sent = ngSent;

        $scope.rec = new Recommendation();
        $scope.rec.media = new Media();

        this.save = function($event) {
            $event.preventDefault();

            Recommendation.save($scope.rec);
        }
    }]);
{% endhighlight %}

And my controller was relatively simple:

{% highlight ruby %}
# app/controllers/recommendations_controller.rb

class RecommendationsController < ApplicationController

    skip_before_action :verify_authenticity_token do
        request.content_type == 'application/json'
    end

    def create
        @rec = Recommendation.new rec_params

        success = @rec.save

        respond_to do |format|
            format.html do
                if success
                    flash[:notice] = 'Recommendation successful!'
                else
                    flash[:error] = 'Recommendation failed.'
                end

                redirect_to users_path
            end

            format.json { render json: {data: @rec, success: success} }
        end
    end

    private

    def rec_params
        params.require(:recommendation).permit(
            :source_id,
            :target_id,
            media_attributes: [:name, :media_type_id]
        )
    end
end
{% endhighlight %}

Since I'm more familiar with the "default" Rails approach of HTML forms and
`x-www-form-urlencoded` request parameters, I set things up with a regular form
builder and controller, then added Angular and JSON-handling after the fact.

I figured a simple setup like this would be a no-brainer for two of the most
powerful web frameworks in the industry, but I was sorely mistaken.

For some reason, the request being generated by Angular's `ngResource` was
considered by Rails to be in HTML format:

{% highlight text %}
Started POST "/recommendations" for 127.0.0.1 at 2014-10-07 16:24:58 -0700
Processing by RecommendationsController#create as HTML
...
Redirected to http://localhost:3000/users
Completed 302 Found in 15ms (ActiveRecord: 5.4ms)
{% endhighlight %}

This was resulting in the `format.html` block being invoked, so my AJAX request
was being given an HTML redirect response. Not good!

But, this didn't make any sense. My request appeared to be well-formed:

{% highlight text %}
POST /recommendations HTTP/1.1
Host: localhost:3000
Accept: application/json, text/plain, */*
Content-Type: application/json;charset=UTF-8
{% endhighlight %}

Time to see what's going on under the hood.

A search for `format` on the Rails API explorer led me to
[ActionDispatch][format_docs], which refers to the `formats` method defined just
beneath it:

{% highlight ruby %}
# actionpack/lib/action_dispatch/http/mime_negotiation.rb

def formats
    @env["action_dispatch.request.formats"] ||=
        if parameters[:format]
            Array(Mime[parameters[:format]])
        elsif use_accept_header && valid_accept_header
            accepts
        elsif xhr?
            [Mime::JS]
        else
            [Mime::HTML]
        end
end
{% endhighlight %}

Some quick `puts` statements showed that the `if` statement was getting all the
way to the final `[Mime::HTML]` clause, which definitely shouldn't be happening!

`parameters[:format]` seems to refer to the explicit format string at the end
of the path, such as `.html` or `.json`, so that clause should be skipped here.

This means we should be hitting either the `accepts` clause or the `[Mime::JS]`
clause. Why is the first one getting skipped?

`use_accept_header` and `valid_accept_header` are defined at the [bottom of the
same file][use_valid_header]:

[use_valid_header]: https://github.com/rails/rails/blob/320124ffebb9311d46a834272879cb0a754562a8/actionpack/lib/action_dispatch/http/mime_negotiation.rb#L139-L146

{% highlight ruby %}
# actionpack/lib/action_dispatch/http/mime_negotiation.rb

def valid_accept_header
    (xhr? && (accept.present? || content_mime_type)) ||
        (accept.present? && accept !~ BROWSER_LIKE_ACCEPTS)
end

def use_accept_header
    !self.class.ignore_accept_header
end
{% endhighlight %}

`use_accept_header` is pretty simple, and it's returning `true` as expected.

However, another `puts` statement showed that this `xhr?` method was returning `false`,
meaning that even if everything else was lined up correctly, neither of the correct
`if` statement clauses would be hit.

But... this **is** an XMLHTTPRequest. Why is `xhr?` returning false?

This method is defined in [request.rb][request_xhr]:

{% highlight ruby %}
# actionpack/lib/action_dispatch/http/request.rb

# Returns true if the "X-Requested-With" header contains "XMLHttpRequest"
# (case-insensitive). All major JavaScript libraries send this header with
# every Ajax request.
def xml_http_request?
    @env['HTTP_X_REQUESTED_WITH'] =~ /XMLHttpRequest/i
end
alias :xhr? :xml_http_request?
{% endhighlight %}

Well, that comment appears to be a little misleading, because I would consider
Angular a major JS library, but it sure isn't setting that header.

To Google!

[**angular/angular.js/issues/1004**][drop_x_req]:

> X-Requested-With causes CORS requests to trigger preflight checks which complicates things for many simple things.
>
> <br />
>
> The header is not very useful except for certain edge-cases (e.g. I think that Rails uses the header to switch full page and page fragment rendering).

Oops.

Welp. You have to wonder: whose fault is this?

Hint: It's "everyone". The answer is that it's everyone's fault. You, me. Everybody, buddy.

A workaround is listed in the [Angular changelog][breaking_changes]:

{% highlight javascript %}
myAppModule.config(['$httpProvider', function($httpProvider) {
    $httpProvider.defaults.headers.common["X-Requested-With"] = 'XMLHttpRequest';
}]);
{% endhighlight %}

I'm gonna go hug my knees and whisper quietly to myself for a while.

[breaking_changes]: https://github.com/angular/angular.js/blob/master/CHANGELOG.md#breaking-changes-37
[drop_x_req]: https://github.com/angular/angular.js/issues/1004
[format_docs]: http://api.rubyonrails.org/classes/ActionDispatch/Http/MimeNegotiation.html#method-i-format
[request_xhr]: https://github.com/rails/rails/blob/320124ffebb9311d46a834272879cb0a754562a8/actionpack/lib/action_dispatch/http/request.rb#L194-L197
